# Core definitions of builtin classes and opcodes.

class Free # unused chunks.
  oop next
class Bytes # arbitrary bytes (of varying length).
  byte[] flex
class Bytecodes # Python bytecodes (of varying length).
  byte[] flex
class MC # 6809/6309 Machine Code (of varying length).
  byte[] flex
class Array # Array (of varying length) of OOPs.
  oop[] flex
class Chain # a chain for an use.
  oop root
  small len2
class List # a chain for a list.
  oop root
  small len2
class Dict # a chain for a dict.
  oop root
  small len2
class Buf
  oop bytes
  small len
class Str
  oop bytes
  small len
  small offset
  small single  # If a single-char string, you can use this target.
class Frame
  oop prev_frame
  oop function
  small nargs
  small prev_sp
  small prev_ip
  oop[] flex
class Class
  small classNum
  oop className
  oop methDict
  oop fieldList

# Opcodes.
code  Abort  # Abort comes first, so 00 means abort.
  [
    assert0(0, "ABORT OP");
  ]
code  Stop  # Stop comes first, so 00 means stop.
  in
  out
  [
    return;
  ]
code  Nop
  in
  out
  [
  ]
code  LitInt
  arg lit
  in
  out z
  [
    z = ( Q(lit) );
  ]
code  LitInt2
  arg hi lo
  in
  out z
  [
    word lit = ((word)hi<<8) + lo;
    z = ( Q(lit) );
  ]
code  LitStr
  arg nth
  in
  out z
  [
    z = ( ChainGetNth(InternList, nth) );
  ]
code  Plus
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    z = ( Q(aa + bb) );
  ]
code  Minus
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    z = ( Q(aa - bb) );
  ]
code  Times
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    z = ( Q(aa * bb) );
  ]
code  Print
  in a
  out
  [
#if unix
    // is hard to see with so much debugging output.
    // make it more obvious
    printf("\n@@@@@ PRINT @@@@@ ");
#endif
    if (a&1) {
      printf("%d ", N(a));
    } else {
      printf("[$%x] ", a);
    }
    fflush(stdout);
  ]
code  Assert
  in a
  out
  [
    assert(Truth(a));
  ]
code  GlobalDict
  in
  out z
  [
    z = GlobalDict;
  ]
code  GlobalGet
  arg nth
  in
  out z
  [
    word addr = ChainAddrOfNth(GlobalDict, nth);
    assert(addr);
    z = GetW(addr);
  ]
code  GlobalPut
  arg nth
  in a
  out
  [
    word addr = ChainAddrOfNth(GlobalDict, nth);
    assert(addr);
    PutW(addr, a);
  ]
code  Branch
  arg whither
  in
  out
  [
        ip = function + whither - 1; // ip++ at bottom of loop.
  ]
code  BranchIfFalse
  arg whither
  in pred
  out
  [
        if (!Truth(pred)) ip = function + whither - 1; // ip++ at bottom of loop.
  ]
code  GetAt
  in coll key
  out z
  [
        z = (  ChainDictGet(coll, key) );
  ]
code  PutAt
  in coll key value
  out
  [
        ChainDictPut(coll, key, value);
  ]
code  EQ
  in a b
  out z
  [
    word p = Equal(a, b);
    z = Q(p);
  ]
code  NE
  in a b
  out z
  [
    word p = !Equal(a, b);
    z = Q(p);
  ]
code  LT
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    word p = (aa < bb);
    z = Q(p);
  ]
code  GT
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    word p = (aa > bb);
    z = Q(p);
  ]
code  LE
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    word p = (aa <= bb);
    z = Q(p);
  ]
code  GE
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    word p = (aa >= bb);
    z = Q(p);
  ]

code ArgGet
  arg i
  out z
  [
    z = ArgGet(i);
  ]

code LocalGet
  arg i
  out z
  [
    z = (  Frame_flex_At(fp, i) );
  ]

code LocalPut
  arg i
  in a
  [
    Frame_flex_AtPut(fp, i, a);
  ]

code Drop
  in unused
  [
    {}
  ]

code Call
  arg nargs
  in fn
  [
   sp += 2;
   Call(nargs, fn);
   goto NEXT;
  ]

code CallMeth
  arg meth_isn nargs
  [
    CallMeth(meth_isn, nargs);
    goto NEXT;
  ]

code Return
  in retval
  [
    byte stop = ReturnPerhapsStop(retval);
    if (stop) return;  // exit the interpreter loop.
    goto NEXT;
  ]
code  RetSelf
  in
  [
    word old_fp = Frame_prev_frame(fp);
    assert (old_fp);
    word old_sp = Frame_prev_sp(fp);
    word self_addr = old_fp + old_sp;  // last on previous stack.
    word self = ogetw(self_addr);
    byte stop = ReturnPerhapsStop(self);
    if (stop) return;  // exit the interpreter loop.
    goto NEXT;
  ]
code  RetNone
  [
    byte stop = ReturnPerhapsStop(None);
    if (stop) return;  // exit the interpreter loop.
    goto NEXT;
  ]
code Construct
  arg cls_num nargs
  [
    bool next = ConstructPerhapsNext(cls_num, nargs);
    if (next) goto NEXT;
  ]
code Dup
  in x
  out x1 x2
  [
    x1 = x2 = x;
  ]
code MemberGet
  arg member
  in obj
  out result
  [
    word z = MemberGet(obj, member);
    result = z;
  ]
code SelfMemberGet
  arg offset
  out result
  [
    word obj = ArgGet(0);
    assert(offset < ocap(obj));
    word addr = obj + offset;
    result = ogetw(addr);
  ]
code MemberPut
  arg member
  in value obj
  [
    MemberPut(obj, member, value);
  ]
code SelfMemberPut
  arg offset2
  in value
  [
    byte offset = offset2<<1;
    word obj = ArgGet(0);
    assert(offset < ocap(obj));
    oputw(obj + offset, value);
  ]
code List
  arg llen
  [
    word z = NewList();
    for (word p = sp + ((word)llen<<1) - 2; p >= sp; p -=2) {
        ChainAppend(z, ogetw(p));
    }
    sp += ((word)llen<<1) - 2;
    oputw(sp, z);
  ]
code Dict
  arg llen
  [
    word z = NewDict();
    for (word p = sp + ((word)llen<<2) - 4; p >= sp; p -=4) {
        ChainDictPut(z, ogetw(p+2), ogetw(p));
    }
    sp += ((word)llen<<2) - 2;
    oputw(sp, z);
  ]
code Len
  in obj
  out length
  [
    word o = obj;
    int n;
    switch (ocls(o)) {
    case C_Str:
        n = Str_len(o);
        break;
    case C_Buf:
        n = Buf_len(o);
        break;
    case C_List:
        n = List_len2(o);
        break;
    case C_Dict:
        n = List_len2(o)>>1;
        break;
    default:
        opanic(101);
    }
    length = FROM_INT(n);
  ]
code GetItem
  in coll key
  out value
  [
    word c = coll;
    word k = key;
    word v;
    switch (ocls(c)) {
    case C_Str: {
        word addr = Str_bytes(c) + Str_offset(c) + TO_INT(k);
        v = SingletonStr(ogetb(addr));
        } break;
    case C_List: {
        int i = TO_INT(k);
        v = ChainGetNth(coll, i);
        } break;
    case C_Dict:
        v = ChainDictGet(coll, k);
        break;
    default:
        opanic(101);
    }
    value = v;
  ]
code Hex
  in x
  out z
  [
    z = x;
  ]
code Ord
  in x
  out z
  [
    word s = x;
    assert(ocls(s) == C_Str);
    word addr = Str_bytes(s) + Str_offset(s);
    byte ch = ogetb(addr);
    z = FROM_INT(ch);
  ]
code Chr
  in x
  out z
  [
    word n = TO_INT(x);
    z = SingletonStr((byte)n);
  ]


meth Str __str__
  in self
  out z
  [
    z = self;
  ]

meth Str __foo__
  in self
  out z
  [
    z = DunderInitStr;
  ]
