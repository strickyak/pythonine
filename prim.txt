# Core definitions of builtin classes and opcodes.

class Free # 0: unused chunks.
  oop next
class SmallInt # 1: Inside OOP with the low bit set.
  # no contents
class Bytes # 2: arbitrary bytes (of varying length).
  byte[] flex
class Buf # 3: byte buffer
  byte[] flex  # first byte is len.
class Bytecodes # 4: Python bytecodes (of varying length).
  byte[] flex
class MC # 5: 6809/6309 Machine Code (of varying length).
  byte[] flex
class Array # Array (of varying length) of OOPs.
  oop[] flex
class Chain # a chain for an use.
  oop root
  small len2
class List # a chain for a list.
  oop root
  small len2
class Tuple # just like List.
  oop root
  small len2
class Dict # a chain for a dict.
  oop root
  small len2
class Module # a Module is made from a Dict.
  oop root
  small len2
class Str
  oop bytes
  small len
  small offset
  small single  # If a single-char string, you can use this target.
class Frame
  oop prev_frame
  oop function
  small nargs
  small prev_sp
  small prev_ip
  oop tries
  oop[] flex
class Class
  small classNum
  oop className
  oop methDict
  oop fieldList
class Try
  small catch_loc
  oop next
class ListIter
  oop base
  oop p
  small i
  small len2
class DictIter
  oop base
  oop p
  small i
  small len4
class StrIter
  oop base
  oop p
  small i
  small len
class File
  small fd
class FileIter
  small fd

# Opcodes.
code  Abort  # Abort comes first, so 00 means abort.
  [
    assert0(0, "ABORT OP");
  ]
code  Stop  # Stop comes first, so 00 means stop.
  in
  out
  [
    return;
  ]
code  Nop
  in
  out
  [
  ]
code  LitInt
  arg lit
  in
  out z
  [
    z = ( Q(lit) );
  ]
code  LitInt2
  arg hi lo
  in
  out z
  [
    word lit = ((word)hi<<8) + lo;
    z = ( Q(lit) );
  ]
code  LitStr
  arg nth
  in
  out z
  [
    z = ( ChainGetNth(InternList, nth) );
  ]
code  Plus
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    z = ( Q(aa + bb) );
  ]
code  Minus
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    z = ( Q(aa - bb) );
  ]
code  Times
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    z = ( Q(aa * bb) );
  ]
code  Print
  in a
  out
  [
#if unix
    // is hard to see with so much debugging output.
    // make it more obvious
    printf("\n@@@@@ PRINT @@@@@ ");
#endif
    SimplePrint(a);
    fflush(stdout);
  ]
code  Assert
  in a
  out
  [
    assert(Truth(a));
  ]
code  GlobalDict
  in
  out z
  [
    z = GlobalDict;
  ]
code  GlobalGet
  arg nth
  in
  out z
  [
    word addr = ChainAddrOfNth(GlobalDict, nth);
    assert(addr);
    z = GetW(addr);
  ]
code  GlobalPut
  arg nth
  in a
  out
  [
    word addr = ChainAddrOfNth(GlobalDict, nth);
    assert(addr);
    PutW(addr, a);
  ]
code  Branch
  arg whither
  in
  out
  [
        ip = function + whither;
  ]
code  BranchIfFalse
  arg whither
  in pred
  out
  [
        if (!Truth(pred)) ip = function + whither;
  ]
code  BranchIfTrue
  arg whither
  in pred
  out
  [
        if (Truth(pred)) ip = function + whither;
  ]
code Not
  in a
  out z
[
  byte x = (byte) !Truth(a);
  z = FROM_INT(x);
]
code Is
  in a b
  out z
[
  byte x = (a == b);
  z = FROM_INT(x);
]
code  EQ
  in a b
  out z
  [
    word p = Equal(a, b);
    z = Q(p);
  ]
code  NE
  in a b
  out z
  [
    word p = !Equal(a, b);
    z = Q(p);
  ]
code  LT
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    word p = (aa < bb);
    z = Q(p);
  ]
code  GT
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    word p = (aa > bb);
    z = Q(p);
  ]
code  LE
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    word p = (aa <= bb);
    z = Q(p);
  ]
code  GE
  in a b
  out z
  [
    int aa = N(a);
    int bb = N(b);
    word p = (aa >= bb);
    z = Q(p);
  ]

code ArgGet
  arg i
  out z
  [
    z = ArgGet(i);
  ]

code LocalGet
  arg i
  out z
  [
    z = (  Frame_flex_At(fp, i) );
  ]

code LocalPut
  arg i
  in a
  [
    Frame_flex_AtPut(fp, i, a);
  ]

code Drop
  in unused
  [
    {}
  ]

code Call
  arg nargs
  [
   Call(nargs, PopSp());  // don't use `in`
  ]

code CallMeth
  arg meth_isn nargs
  [
    CallMeth(meth_isn, nargs);
  ]

code Return
  [
    Return(PopSp());  // don't use `in`
  ]
code  RetSelf
  [
    Return(ArgGet(0));
  ]
code  RetNone
  [
    Return(None);
  ]
code Construct
  arg cls_num nargs
  [
    Construct(cls_num, nargs);
  ]
code Dup
  in x
  out x1 x2
  [
    x1 = x2 = x;
  ]
code MemberGet
  arg member
  in obj
  out result
  [
    word z = MemberGet(obj, member);
    result = z;
  ]
code SelfMemberGet
  arg offset
  out result
  [
    word obj = ArgGet(0);
    assert(offset < ocap(obj));
    word addr = obj + offset;
    result = ogetw(addr);
  ]
code MemberPut
  arg member
  in value obj
  [
    MemberPut(obj, member, value);
  ]
code SelfMemberPut
  arg offset2
  in value
  [
    byte offset = offset2<<1;
    word obj = ArgGet(0);
    assert(offset < ocap(obj));
    oputw(obj + offset, value);
  ]
code NewTuple
  arg llen
  [
    Implode(llen, NewTuple());
  ]
code NewList
  arg llen
  [
    Implode(llen, NewList());
  ]
code NewDict
  arg llen
  [
    Implode(llen<<1, NewDict());
  ]
code Len
  in obj
  out length
  [
    int n = Len(obj);
    length = FROM_INT(n);
  ]
code GetItem
  in coll key
  out value
[
  value = GetItem(coll, key);
]
code PutItem
  in value coll key
[
  PutItem(coll, key, value);
]
code Ord
  in x
  out z
  [
    word s = x;
    assert(ocls(s) == C_Str);
    word addr = Str_bytes(s) + Str_offset(s);
    byte ch = ogetb(addr);
    z = FROM_INT(ch);
  ]
code Chr
  in x
  out z
  [
    word n = TO_INT(x);
    z = SingletonStr((byte)n);
  ]
code Try
  arg catch_loc
[
  DoTry(catch_loc);
]
code EndTry
  arg end_catch_loc
[
  // Pop the `tries` entry and branch to after the Catch block.
  // The Catch instruction always follows.
  DoEndTry(end_catch_loc);
]
code Catch
[
  // A no-op just to make bytecode traces more readable.
  // This is the landing point afer a Raise in a Try block.
  // Once we arrive here, the exception object is on the stack,
  // and the exception is considered handled, from the point
  // of view of the bytecode engine.
]
code Raise
[
   Raise(PopSp());  // Don't use `in`
]
code Explode
  arg len
[
  Explode(len);
]
code Range
  in n_
  out list
[
  int n = TO_INT(n_);
  word z = NewList();
  for (int i=0; i<n; i++) {
    ListAppend(z, FROM_INT(i));
    SayObj(z, 3);
  }
  list = z;
]
code Import
  in name
[
  RaiseC("todo_import");
]
code Directory
[
  Directory();  // A demo/debugging opcode.
]
code SpecialStdin
  out z
[
  z = Stdin;
]
code SpecialStdout
  out z
[
  z = Stdout;
]
code SpecialStderr
  out z
[
  z = Stderr;
]
code Open
  in mode filename
  out z
[
  z = PyOpenFile(filename, mode);
]
code SpecialTrue
  out z
[
  z = FROM_INT(true);
]
code SpecialFalse
  out z
[
  z = FROM_INT(false);
]
code SpecialNone
  out z
[
  z = None;
]

prim Str __str__
  in self
  out z
[
  z = self;
]

prim Str __foo__
  in self
  out z
[
  z = DunderInitStr;
]

prim List __iter__
  in self
  out z
[
  z = NewListIter(self);
]

prim ListIter next
  in self
  out z
[
  z = ListIterNext(self);
]

prim Tuple __iter__
  in self
  out z
[
  // ListIter works for Tuple.
  z = NewListIter(self);
]

prim Dict __iter__
  in self
  out z
[
  z = NewDictIter(self);
]

prim DictIter next
  in self
  out z
[
  z = DictIterNext(self);
]

prim Module __iter__
  in self
  out z
[
  // Dict iter works for Module.
  z = NewDictIter(self);
]

prim Module __getattr__
  in self key
  out z
[
  // TODO: Should we use __getattr__ or hardwire Module?
  z = DictGet(self, key);
]

prim File __iter__
  in self
  out z
[
  z = oalloc(FileIter_Size, C_FileIter);
  FileIter_fd_Put(z, File_fd(self));
]

prim FileIter next
  in self
  out z
[
  z = FileReadLineToNewBuf(self);
  if (!z) RaiseC("StopIteration");
]
prim File close
  in self
[
  RaiseC("unimp");
]
